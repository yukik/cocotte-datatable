cocotte-datatable
============

# はじめに

データテーブルは、データソースの一部もしくは全部の行を参照します  
データテーブルは個別に行の絞り込みのための条件や、並び順、現在行を持ちます  
データソースの操作は参照するデータテーブルすべてに影響します  

# 使用方法

```
// データソースの作成
var Datasource = require('cocotte-datasource');
var Field = require('cocotte-field');
var config = {
  fields: {
    name: {type: Field.Text},
    age : {type: Field.Number}
  }
};
var ds = new Datasource(config);
ds.add({name: 'foo', age: 16});
ds.add({name: 'bar', age: 13});
ds.add({name: 'baz', age: 20});
ds.add({name: 'qux', age: 19});

// データテーブルを作成
var Datatable = require('cocotte-datatable');
var dt = new Datatable(ds);
// 行の絞り込みを設定
dt.setCondition({age: [null, 19]});
// 並び順を設定
dt.setOrder('name');
// 開始・終了行を設定
dt.range = [1, 3];
// 行を取得
dt.list();
// 現在行を設定
dt.currentIndex = 0;
```

# 破棄

データテーブルは、データソースのイベントを監視するためインスタンスの破棄を行わないと
参照が残った

# プロパティ

## ds

  + 参照元データソース

## Row

  + 型付の行クラス

## rows

  + インデックスを指定して行を参照します

## fields

  + フィールド

## length

  + 行数

## condition

  + 絞り込み条件
  + `{フィールド名: 条件}`のようにオブジェクトを返します
  + 変更することもできます。`setCondition({フィールド名: 条件})`と同じ

## order

  + 並び順
  + `[[フィールド名1, 昇順],[フィールド名2, 昇順]...]`のような配列を返します
  + 変更することもできます。`setOrder([[フィールド名1, 昇順],[フィールド名2, 昇順]...])`と同じ

## range

  + 開始行・終了行のインデックス
  + `[開始, 終了]`のように配列を返します
  + 変更することもできます。`setRange(開始, 終了)`と同じ

## liveList

  + 元のデータソースに変更があった場合や取得条件に変更があった場合に行リストを自動的に更新します
  + 既定値はfalseです
  + フォームリストでは、入力の度にリストが更新されてしまうためfalseにします
  + 表示用リストは、trueにすることで常に最新のリストを確認でき便利です

## currentRow

  + 現在行
  + 現在行が存在しない場合は、nullになります

## currentIndex

  + 現在行のインデックス
  + 現在行が存在しない場合は、-1になります


# メソッド

## add({Object} data)

  + 行を追加します
  + 引数は省略できます
  + 戻り値は追加された行です
  + 絞り込み条件が存在する場合に、フィールド値が単一値の場合は自動的に設定されます
  + 並び順の設定を無視して最終行に追加します
  + その後、liveListがtrueになっていると、自動的にリストが更新されてしまいます
      + これにより、リストから消えてしまったり、順番が変わってしまうことがあります
      + 他に編集中の行があった場合は、変更内容が保存されなくなります

## remove({Row} row)

  + 指定行をデータソースから排除します
  + データテーブルに含まれていない行は削除できません
  + 戻り値は排除できたかどうかです
  
## removeAll()

  + データテーブルのすべての行をデータソースから排除します
  + 戻り値は削除した行数です

## exists({Row} row)

  + 対象の行をデータテーブルが保有しているか
  + statusがRow.STATES.DETACHEDの行でもtrueになります
  + そのためデータソースにはなく、データテーブルのみ存在する行を持っていることがあります

## find({String|Object} id|condition)

  + 行を取得します
  + 一致する行が複数存在する場合は最初に一致した行が返されます
  + 文字列を指定した場合は、idが一致する行を探します
  + オブジェクトを指定した場合は、フィールドを指定して値が一致した行を探します

## list()

  + データテーブルの行リストを更新します
  + 行リストは絞り込み時に条件、並び順、開始行、終了行に影響します
  + 戻り値は取得した行数です

## test({Row} row)

  + 絞り込み条件に該当する行か判定します
  + conditionのみ影響し、order,rangeの影響はうけません

## setCondition({Object} condition)

  + 絞り込み条件を設定する
  + キーをフィールド名に値に条件を指定したオブジェクトで設定します
  + `{name:'foo}`はnameフィールドが'foo'の値の行を抽出します
      + この状態は単一値の条件となり、addに影響します
  + `{age: [10, 19]}`はageフィールドが10から19の値の行を抽出します
      + 開始か終了をnullにすると以上、以下となります
  + `{age: function(v){return v%2;}}`はageフィールドが奇数の行を抽出します
      + 判定を行う関数の第一引数には指定フィールドの値が、第二引数には行が、第三引数にはデータテーブルが渡されます
      + 複雑な条件を設定することができます

## setOrder({String|Array} order)

  + 並び順を設定する
  + 配列で設定した場合は、`[[フィールド名1, 昇順], [フィールド名2, 昇順]...]`となります
  + 文字列を設定した場合は、フィールド名をカンマ区切りで設定したこととなります
      + 降順の設定はフィールド名の前に-を追加します

## setRange({Number} from, {Number} to)

  + 開始行・終了行を指定します
  + 終了行にnullを設定すると最後の行まで取得します

## getState({Row} row, {String} state)

  + 対象行のstateで指定した情報を返します
  + stateで指定できるのは以下のとおり
      + index: 0から始まるインデックス
      + first: 最初の行かどうかの真偽値
      + last: 最後の行かどうかの真偽値
      + middle: 最初でも最後でもない行かどうかの真偽値
      + odd: 奇数行かどうかの真偽値
      + even: 偶数行かどうかの真偽値
  + oddとevenはインデックスの数字と意味が逆になるので注意してください
  + いずれも対象行がデータテーブルに存在しない場合はnullを返します

## first()

  + 最初の行を現在行にします
  + 戻り値は、移動できたかどうかです

## next()

  + 次の行に移動します
  + 現在行が未設定の場合は、最初の行に移動します
  + 最後の行の場合は、移動しません
  + 戻り値は、移動できたかどうかです

## back()

  + 次の行に移動します
  + 現在行が未設定の場合は、最後の行に移動します
  + 最初の行の場合は、移動しません
  + 戻り値は、移動できたかどうかです

## last()

  + 最初の行を現在行にします
  + 戻り値は、移動できたかどうかです

## move({Number|Row} index|row)

  + 指定した行に移動します
  + 戻り値は、移動できたかどうかです

## forEach({Function} callback)

  + 全行を順次取得し、`callback`を実行します
  + `callback`の第一引数に行を、第二引数にインデックスを、第三引数に行全体の配列を渡されます

## every({Function} callback)

  + すべての行に対して`callback`の結果が真であるかを調べます
  + `callback`の第一引数に行を、第二引数にインデックスを、第三引数に行全体の配列を渡されます

## some({Function} callback)

  + いずれかの行に対して`callback`の結果が真であるかを調べます
  + `callback`の第一引数に行を、第二引数にインデックスを、第三引数に行全体の配列を渡されます

## filter ({Function} callback)

  + `callback`を満たす行を配列で返します
  + `callback`の第一引数に行を、第二引数にインデックスを、第三引数に行全体の配列を渡されます

## map({Function} callback)

  + 各行から新しい配列を作成します
  + `callback`の第一引数に行を、第二引数にインデックスを、第三引数に行全体の配列を渡されます

## reduce({Function} callback, {Mixed} initial)

  + 各行から値を計算します
  + `callback`には４つの引数が渡されます
  + `callback`の前回の戻り値が次の第一引数に渡されます
  + 最初のみinitialが渡されます
  + 第二引数以降は、行・インデックス・行全体の順で渡されます
  + `initial`は一番最初の行を処理する際の第一引数です
  + `initial`を省略した場合は`undefined`です

## reduceRight({Function} callback, {Mixed} initial)

  + 各行をインデックスの降順で値を計算します
  + それ以外は`reduce`と同じです

# イベント

`dt.on(イベント名, コールバック関数)`でイベントを捕捉することができま

## added ({Row} row)

  + データテーブル経由で行が追加された
  + liveListがfalseの場合のみ発生します

## removed ({Row} row)

  + データテーブル経由で行が削除された
  + liveListがfalseの場合のみ発生します

## updated ({Row} row, {String} fieldName)

  + 値が更新された
  + rowは更新された行です
  + fieldNameは更新されたフィールド名です
  + liveListがtrueの場合
      + 更新によりリストから排除されたり、新たに追加になった場合はイベントは発生しません
      + 前項の場合はlistedイベントが発生します

## listed()

  + リストに変更があった
  + 以下の条件に当てはまる場合は、リストの再取得が発生します
      + listメソッドが呼ばれた
      + liveListがtrueの場合
        + 抽出条件が変更された
        + 並び順が変更された
        + 開始行・終了行の範囲が変更された
        + データソースに行の追加・削除された
        + 値が変更になったフィールドが、抽出条件もしくは並び順に関係していた
            + データテーブルに存在しない行でもリストの再取得を行います
  + リストの再取得が発生しても、リストに変更がなければイベントは発生しません

## moved({Row} row)

  + 現在行が移動した
  + rowは移動先の行です
  + リストが更新されても同じ行を参照している場合はmovedイベントは起きません
